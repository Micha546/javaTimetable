package Main.Engine.Evolution.TimeTableSolution.Classes;

import Main.Engine.Evolution.*;
import Main.Engine.Evolution.TimeTableSolution.CrossOvers.TimeTableCrossOvers;
import Main.Engine.Evolution.TimeTableSolution.DTO.*;
import Main.Engine.Evolution.TimeTableSolution.Mutations.TimeTableMutationWrapper;
import Main.Engine.Evolution.TimeTableSolution.Mutations.TimeTableMutations;
import Main.Engine.Evolution.TimeTableSolution.Rules.TimeTableRules;
import Main.Engine.Evolution.TimeTableSolution.Selections.TimeTableSelections;
import Main.Engine.Xml.AutoGenerated.*;
import javafx.util.Pair;

import java.sql.Wrapper;
import java.util.*;
import java.util.stream.Collectors;

public class TimeTableManager implements AlgorithmManager {
    private final Integer days;
    private final Integer hours;
    private List<Grade> allGrades;
    private List<Subject> allSubjects;
    private List<Teacher> allTeachers;
    private TimeTableCrossOvers crossOver;
    private Integer crossOverCutSize;
    private Object[] crossOverArgs;
    private List<TimeTableMutationWrapper> mutationsWrapperList;      // TODO CHANGE TO WRAPPER
    private TimeTableSelections selection;
    private Object[] selectionArgs;
    private Integer elitism;
    private Map<TimeTableRules, Pair<Rule.Severity, Object[]>> rulesPairMap;
    private Integer hardRuleWeight;
    private Integer populationSize;

    public TimeTableManager(ETTDescriptor ettDescriptor) {
        this.days = getDaysFromETT(ettDescriptor);
        this.hours = getHoursFromETT(ettDescriptor);
        this.allGrades = generateGradesListFromETT(ettDescriptor.getETTTimeTable().getETTClasses());
        this.allSubjects = generateSubjectListFromETT(ettDescriptor.getETTTimeTable().getETTSubjects());
        this.allTeachers = generateTeacherListFromETT(ettDescriptor.getETTTimeTable().getETTTeachers());
        this.crossOver = getCrossOverFromETT(ettDescriptor);
        this.crossOverCutSize = getCrossOverCutSizeFromETT(ettDescriptor);
        this.crossOverArgs = getCrossOverArgsFromETT(ettDescriptor);
        this.mutationsWrapperList = getMutationsFromETT(ettDescriptor.getETTEvolutionEngine().getETTMutations());
        this.selection = getSelectionFromETT(ettDescriptor);
        this.selectionArgs = getSelectionArgsFromETT(ettDescriptor);
        this.elitism = getElitismFromETT(ettDescriptor);
        this.rulesPairMap = getRulesFromETT(ettDescriptor.getETTTimeTable().getETTRules());
        this.hardRuleWeight = getHardRuleWeightFromETT(ettDescriptor.getETTTimeTable().getETTRules());
        this.populationSize = getPopulationSizeFromEET(ettDescriptor);
    }

    public Integer getRandomDay()
    {
        Random rand = new Random();
        return rand.nextInt(days) + 1;
    }

    public Integer getRandomHour()
    {
        Random rand = new Random();
        return rand.nextInt(hours) + 1;
    }

    public Grade getRandomGrade()
    {
        Random rand = new Random();
        return allGrades.get(rand.nextInt(allGrades.size()));
    }

    public Subject getRandomSubject()
    {
        Random rand = new Random();
        return allSubjects.get(rand.nextInt(allSubjects.size()));
    }

    public Teacher getRandomTeacher()
    {
        Random rand = new Random();
        return allTeachers.get(rand.nextInt(allTeachers.size()));
    }

    private Integer getDaysFromETT(ETTDescriptor ettDescriptor)
    {
        return ettDescriptor.getETTTimeTable().getDays();
    }

    private Integer getHoursFromETT(ETTDescriptor ettDescriptor)
    {
        return ettDescriptor.getETTTimeTable().getHours();
    }

    private List<Grade> generateGradesListFromETT(ETTClasses gradesInETT)
    {
        allGrades = new ArrayList<>();

        for(ETTClass ettGrade : gradesInETT.getETTClass())
            allGrades.add(new Grade(ettGrade));

        return allGrades;
    }

    private List<Subject> generateSubjectListFromETT(ETTSubjects subjectsInETT)
    {
        allSubjects = new ArrayList<>();

        for(ETTSubject ettSubject : subjectsInETT.getETTSubject())
            allSubjects.add(new Subject(ettSubject));

        return allSubjects;
    }

    private List<Teacher> generateTeacherListFromETT(ETTTeachers teachersInEET)
    {
        allTeachers = new ArrayList<>();

        for(ETTTeacher ettTeacher : teachersInEET.getETTTeacher())
            allTeachers.add(new Teacher(ettTeacher));

        return allTeachers;
    }

    private TimeTableCrossOvers getCrossOverFromETT(ETTDescriptor ettDescriptor)
    {
        return TimeTableCrossOvers.valueOf(ettDescriptor.getETTEvolutionEngine().getETTCrossover().getName());
    }

    private Integer getCrossOverCutSizeFromETT(ETTDescriptor ettDescriptor)
    {
        return ettDescriptor.getETTEvolutionEngine().getETTCrossover().getCuttingPoints();
    }

    private Object[] getCrossOverArgsFromETT(ETTDescriptor ettDescriptor)
    {
        switch(ettDescriptor.getETTEvolutionEngine().getETTCrossover().getName())
        {
            case "DayTimeOriented":
                return new Object[] {};
            case "AspectOriented":
                return new Object[] {
                        ettDescriptor.getETTEvolutionEngine().getETTCrossover().getConfiguration().split("=")[1]
                };
            default:
                throw new RuntimeException("need to add the new crossOver to " +
                        "Main.Engine.Evolution.TimeTableSolution.Classes.getCrossOverArgsFromETT");
        }
    }

    private List<TimeTableMutationWrapper> getMutationsFromETT(ETTMutations ettMutations)
    {
        List<TimeTableMutationWrapper> mutationList = new ArrayList<>();

        for(ETTMutation mutation : ettMutations.getETTMutation())
        {
            TimeTableMutations timeTableMutation;
            int probability;
            List<Object> argsList = new ArrayList<>();

            switch(mutation.getName())
            {
                case "Flipping":
                    probability = (int)(mutation.getProbability() * 100);

                    String[] argsStr = mutation.getConfiguration().split(",");
                    argsList.add((Integer) Integer.parseInt(argsStr[0].split("=")[1]));
                    argsList.add((Character) argsStr[1].split("=")[1].charAt(0));

                    switch ((Character) argsList.get(1))
                    {
                        case 'S':
                            timeTableMutation = TimeTableMutations.FlippingSubject;
                            break;
                        case 'T':
                            timeTableMutation = TimeTableMutations.FlippingTeacher;
                            break;
                        case 'C':
                            timeTableMutation = TimeTableMutations.FlippingGrade;
                            break;
                        case 'H':
                            timeTableMutation = TimeTableMutations.FlippingHour;
                            break;
                        case 'D':
                            timeTableMutation = TimeTableMutations.FlippingDay;
                            break;
                        default:
                            throw new RuntimeException("Unknown Flipping component was read from ettDescriptor");
                    }
                    break;
                case "Sizer":
                    probability = (int)(mutation.getProbability() * 100);
                    argsList.add((Integer) Integer.parseInt(mutation.getConfiguration().split("=")[1]));

                    timeTableMutation = TimeTableMutations.Sizer;
                    break;
                default:
                    throw new RuntimeException("need to add the new mutation to " +
                            "Main.Engine.Evolution.TimeTableSolution.Classes.getMutationsFromETT");
            }

            mutationList.add(new TimeTableMutationWrapper(timeTableMutation, probability, argsList.toArray()));
        }

        return mutationList;
    }

    private TimeTableSelections getSelectionFromETT(ETTDescriptor ettDescriptor)
    {
        return TimeTableSelections.valueOf(ettDescriptor.getETTEvolutionEngine().getETTSelection().getType());
    }

    private Object[] getSelectionArgsFromETT(ETTDescriptor ettDescriptor)
    {
        switch (ettDescriptor.getETTEvolutionEngine().getETTSelection().getType())
        {
            case "Truncation":
                return new Object[] {Integer.parseInt(
                        ettDescriptor.getETTEvolutionEngine().getETTSelection().getConfiguration().split("=")[1]
                )};
            case "RouletteWheel":
                return new Object[] {};
            case "Tournament":
                return new Object[] {Double.parseDouble(
                        ettDescriptor.getETTEvolutionEngine().getETTSelection().getConfiguration().split("=")[1]
                )};
            default:
                throw new RuntimeException("need to add the new selection to " +
                        "Main.Engine.Evolution.TimeTableSolution.Classes.getSelectionArgsFromETT");
        }
    }

    private Integer getElitismFromETT(ETTDescriptor ettDescriptor)
    {
        return ettDescriptor.getETTEvolutionEngine().getETTSelection().getETTElitism();
    }

    private Map<TimeTableRules, Pair<Rule.Severity, Object[]>> getRulesFromETT(ETTRules ettRules)
    {
        Map<TimeTableRules, Pair<Rule.Severity, Object[]>> rulesMap = new HashMap<>();

        for(ETTRule ettRule : ettRules.getETTRule())
        {
            TimeTableRules rule = TimeTableRules.valueOf(ettRule.getETTRuleId());
            Rule.Severity severity = Rule.Severity.valueOf(ettRule.getType());
            List<Object> argsList = getRuleArgs(ettRule);

            rulesMap.put(rule, new Pair<>(severity, argsList.toArray()));
        }

        return rulesMap;
    }

    private List<Object> getRuleArgs(ETTRule ettRule)
    {
        List<Object> argsList = new ArrayList<>();

        if(ettRule.getETTConfiguration() != null)
        {
            argsList.add(Integer.parseInt(ettRule.getETTConfiguration().split("=")[1]));
        }

        return argsList;
    }

    private Integer getHardRuleWeightFromETT(ETTRules ettRules)
    {
        return ettRules.getHardRulesWeight();
    }

    private Integer getPopulationSizeFromEET(ETTDescriptor ettDescriptor)
    {
        return ettDescriptor.getETTEvolutionEngine().getETTInitialPopulation().getSize();
    }

    public Integer getDays() {
        return days;
    }

    public Integer getHours() {
        return hours;
    }

    public List<Grade> getAllGrades() {
        return allGrades;
    }

    public List<Subject> getAllSubjects() {
        return allSubjects;
    }

    public List<Teacher> getAllTeachers() {
        return allTeachers;
    }

    @Override
    public CrossOver getCrossOver() {
        return crossOver;
    }

    @Override
    public Integer getCrossOverCutSize() {
        return crossOverCutSize;
    }

    @Override
    public Object[] getCrossOverArguments() {
        return crossOverArgs;
    }

    @Override
    public List<Mutation> getMutations() {
        return new ArrayList<>(mutationsWrapperList);
    }

    @Override
    public Object[] getMutationArguments(Mutation mutation) {
        if(!(mutation instanceof TimeTableMutationWrapper))
            throw new RuntimeException("Expected to get TimeTableMutationWrapper in getMutationArguments " +
                    "but got "+ mutation.getClass().getName());

        TimeTableMutationWrapper wrapper = (TimeTableMutationWrapper) mutation;
        return wrapper.getMutationArguments();
    }

    @Override
    public Integer getMutationProbability(Mutation mutation) {
        if(!(mutation instanceof TimeTableMutationWrapper))
            throw new RuntimeException("Expected to get TimeTableMutationWrapper in getMutationProbability " +
                    "but got "+ mutation.getClass().getName());

        TimeTableMutationWrapper wrapper = (TimeTableMutationWrapper) mutation;
        return wrapper.getProbability();
    }

    @Override
    public Selection getSelection() {
        return selection;
    }

    @Override
    public Object[] getSelectionArguments() {
        return selectionArgs;
    }

    @Override
    public Integer getElitism() {
        return elitism;
    }

    @Override
    public Set<Rule> getRules() {
        return new HashSet<>(rulesPairMap.keySet());
    }


    @Override
    public Rule.Severity getRuleSeverity(Rule rule) {
        return rulesPairMap.get(rule).getKey();
    }

    @Override
    public Object[] getRuleArguments(Rule rule) {
        return rulesPairMap.get(rule).getValue();
    }

    @Override
    public Integer getHardRuleWeight() {
        return hardRuleWeight;
    }

    @Override
    public Integer getInitialPopulationSize() {
        return populationSize;
    }

    @Override
    public InformationCarrier getDTOManager() {
        return new DTOTimeTableManager(this);
    }

    @Override
    public InformationCarrier getDTOCrossOver(CrossOver crossOver)
    {
        if(!(crossOver instanceof TimeTableCrossOvers))
            throw new RuntimeException(this.getClass().getName() + " expected to get a TimeTableCrossOver");

        return new DTOTimeTableCrossOver((TimeTableCrossOvers) crossOver, crossOverCutSize, Arrays.asList(crossOverArgs));
    }

    @Override
    public InformationCarrier getDTOMutation(Mutation mutation) {
        if(!(mutation instanceof TimeTableMutationWrapper))
            throw new RuntimeException(this.getClass().getName() + " expected to get a TimeTableMutationWrapper");

        TimeTableMutationWrapper wrapper = (TimeTableMutationWrapper) mutation;

        return new DTOTimeTableMutation(wrapper);
    }

    @Override
    public InformationCarrier getDTOSelection(Selection selection) {
        if(!(selection instanceof TimeTableSelections))
            throw new RuntimeException(this.getClass().getName() + " expected to get a TimeTableSelection");

        TimeTableSelections timeTableSelection = (TimeTableSelections) selection;

        return new DTOTimeTableSelection(
                timeTableSelection, elitism, Arrays.stream(selectionArgs).collect(Collectors.toList()));
    }

    @Override
    public InformationCarrier getDTORule(Rule rule) {
        if(!(rule instanceof TimeTableRules))
            throw new RuntimeException(this.getClass().getName() + " expected to get a TimeTableRule");

        TimeTableRules timeTableRule = (TimeTableRules) rule;
        Rule.Severity severity = rulesPairMap.get(timeTableRule).getKey();
        List<Object> ruleArgs = Arrays.asList(rulesPairMap.get(timeTableRule).getValue());

        return new DTOTimeTableRules(timeTableRule, severity, ruleArgs, hardRuleWeight);
    }

    @Override
    public void setCrossOver(InformationCarrier dtoCrossOver) {
        if(!(dtoCrossOver instanceof DTOTimeTableCrossOver))
            throw new RuntimeException("Expected to get DTOTimeTableCrossOver in " + this.getClass().getName());

        DTOTimeTableCrossOver dtoTimeTableCrossOver = (DTOTimeTableCrossOver) dtoCrossOver;

        crossOver = TimeTableCrossOvers.valueOf(dtoTimeTableCrossOver.getCrossOverName());

        crossOverCutSize = dtoTimeTableCrossOver.getCutSize();

        crossOverArgs = dtoTimeTableCrossOver.getArguments().toArray();
    }

    @Override
    public void setSelection(InformationCarrier dtoSelection) {
        if(!(dtoSelection instanceof DTOTimeTableSelection))
            throw new RuntimeException("Expected to get DTOTimeTableSelection in " + this.getClass().getName());

        DTOTimeTableSelection dtoTimeTableSelection = (DTOTimeTableSelection) dtoSelection;

        selection = TimeTableSelections.valueOf(dtoTimeTableSelection.getSelectionName());

        elitism = dtoTimeTableSelection.getElitism();

        selectionArgs = dtoTimeTableSelection.getSelectionArgumentsList().toArray();
    }

    @Override
    public void addMutation(InformationCarrier dtoMutation) {
        if(!(dtoMutation instanceof DTOTimeTableMutation))
            throw new RuntimeException("Expected to get DTOTimeTableMutation in " + this.getClass().getName());

        DTOTimeTableMutation dtoTimeTableMutation = (DTOTimeTableMutation) dtoMutation;

        TimeTableMutations mutation = TimeTableMutations.valueOf(dtoTimeTableMutation.getMutationName());

        mutationsWrapperList.add(new TimeTableMutationWrapper(
                mutation,
                dtoTimeTableMutation.getProbability(),
                dtoTimeTableMutation.getMutationArgs().toArray()));
    }

    @Override
    public void deleteMutation(InformationCarrier dtoMutation) {
        if(!(dtoMutation instanceof DTOTimeTableMutation))
            throw new RuntimeException("Expected to get DTOTimeTableMutation in " + this.getClass().getName());

        DTOTimeTableMutation dtoTimeTableMutation = (DTOTimeTableMutation) dtoMutation;

        Optional<TimeTableMutationWrapper> wrapperToDelete = findMutation(dtoTimeTableMutation);

        if(wrapperToDelete.isPresent())
            mutationsWrapperList.remove(wrapperToDelete.get());
        else
            throw new RuntimeException("Something went wrong when trying to delete a mutation!");
    }

    @Override
    public void changeMutationProbability(InformationCarrier dtoMutation, Integer newProbability) {
        DTOTimeTableMutation dtoTimeTableMutation = (DTOTimeTableMutation) dtoMutation;

        Optional<TimeTableMutationWrapper> wrapperToChange = findMutation(dtoTimeTableMutation);

        if(wrapperToChange.isPresent())
            wrapperToChange.get().setProbability(newProbability);
        else
            throw new RuntimeException("Something went wrong when trying to Change probability!");
    }

    private Optional<TimeTableMutationWrapper> findMutation(DTOTimeTableMutation dtoTimeTableMutation)
    {
        return mutationsWrapperList.stream()
                .filter(wrapper -> wrapper.getTimeTableMutation().name().equals(dtoTimeTableMutation.getMutationName()))
                .filter(wrapper -> wrapper.getProbability().equals(dtoTimeTableMutation.getProbability()))
                .filter(wrapper -> Arrays.equals(wrapper.getMutationArguments(), dtoTimeTableMutation.getMutationArgs().toArray()))
                .findFirst();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        TimeTableManager that = (TimeTableManager) o;
        return Objects.equals(days, that.days) && Objects.equals(hours, that.hours) &&
                Objects.equals(allGrades, that.allGrades) && Objects.equals(allSubjects, that.allSubjects)
                && Objects.equals(allTeachers, that.allTeachers) && crossOver == that.crossOver &&
                Objects.equals(crossOverCutSize, that.crossOverCutSize) &&
                Objects.equals(mutationsWrapperList, that.mutationsWrapperList) && selection == that.selection &&
                Arrays.equals(selectionArgs, that.selectionArgs) && Objects.equals(rulesPairMap, that.rulesPairMap)
                && Objects.equals(hardRuleWeight, that.hardRuleWeight) &&
                Objects.equals(populationSize, that.populationSize);
    }

    @Override
    public int hashCode() {
        int result = Objects.hash(days, hours, allGrades, allSubjects, allTeachers, crossOver,
                crossOverCutSize, mutationsWrapperList, selection, rulesPairMap, hardRuleWeight, populationSize);
        result = 31 * result + Arrays.hashCode(selectionArgs);
        return result;
    }
}
